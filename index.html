<!doctype html>
<html>
<head>
<meta charset="utf-8"/>
<title>hack.chat-like client (single file)</title>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<style>
  :root{--bg:#0b0b0b;--accent:#39d353;--muted:#2a2a2a;--text:#dfffe0}
  html,body{height:100%;margin:0;background:linear-gradient(180deg,#020202,#0b0b0b);font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, "Roboto Mono", monospace;color:var(--text)}
  .app{max-width:900px;margin:18px auto;border-radius:8px;overflow:hidden;border:1px solid rgba(255,255,255,0.03);box-shadow:0 8px 40px rgba(0,0,0,0.6)}
  header{background:#070707;padding:12px 16px;display:flex;align-items:center;gap:12px}
  header .title{font-weight:700;color:var(--accent)}
  main{display:flex;height:72vh}
  .sidebar{width:260px;border-right:1px solid rgba(255,255,255,0.03);padding:12px;background:linear-gradient(180deg,#070707,#0b0b0b)}
  .roomLabel{font-size:13px;color:#9fb39f;margin-bottom:8px}
  .nickBox{display:flex;gap:8px;margin-bottom:8px}
  .nickBox input{flex:1;padding:10px;border-radius:6px;border:1px solid #222;background:#0e0e0e;color:var(--text)}
  .btn{padding:9px 12px;border-radius:6px;border:1px solid rgba(255,255,255,0.03);background:#111;color:var(--accent);cursor:pointer}
  .mainArea{flex:1;display:flex;flex-direction:column}
  #log{flex:1;padding:12px;overflow:auto;background:linear-gradient(180deg,#040404,#070707)}
  .line{margin:6px 0;padding:8px 10px;border-radius:6px;background:rgba(255,255,255,0.02)}
  .line.me{background:linear-gradient(90deg,#0e3b7a,#1e90ff);color:white;text-align:right}
  .meta{font-size:12px;color:#9fb39f;margin-bottom:6px}
  .sendBox{display:flex;padding:12px;border-top:1px solid rgba(255,255,255,0.03);gap:8px}
  .sendBox input{flex:1;padding:12px;border-radius:6px;border:1px solid #222;background:#0e0e0e;color:var(--text)}
  .small{font-size:12px;color:#9fb39f}
  .sys{font-size:12px;color:#bbb;opacity:0.9}
</style>
</head>
<body>
<div class="app" role="application" aria-label="Private hack.chat-like client">
  <header>
    <div class="title">Private Chat</div>
    <div style="margin-left:auto" class="small">hack.chat relay client</div>
  </header>

  <main>
    <aside class="sidebar" aria-hidden="false">
      <div class="roomLabel">Room (from URL)</div>
      <div id="roomDisplay" class="small sys">—</div>

      <div style="margin-top:14px" class="roomLabel">Nickname</div>
      <div class="nickBox">
        <input id="nickInput" placeholder="choose a nick" />
        <button id="joinBtn" class="btn">Join</button>
      </div>

      <div style="margin-top:16px" class="roomLabel">Connection</div>
      <div id="status" class="small sys">disconnected</div>

      <div style="margin-top:12px" class="roomLabel">Hints</div>
      <div class="small">Open this same page (same ?room=NAME) in another tab or give the URL to the other person.</div>
      <div style="margin-top:8px" class="small">Room privacy: pick a unique room name nobody else knows.</div>
    </aside>

    <section class="mainArea">
      <div id="log" aria-live="polite"></div>

      <div class="sendBox">
        <input id="msgInput" placeholder="Type message and press Enter" aria-label="message input" />
        <button id="sendBtn" class="btn">Send</button>
      </div>
    </section>
  </main>
</div>

<script>
/* ========= behavior =========
 - Reads room from:
    ?room=NAME  OR ?(NAME)  OR location.hash
 - Connects to wss://ws.hack.chat/chat-ws
 - Sends proper join: {cmd:"join",nick:N,channel:ROOM}
 - Sends chat: {cmd:"chat", text: "..."}   <-- NO channel here
 - Shows own messages locally and remote messages.
 - Enter to send, reconnect attempts on close.
*/

// helper DOM
const $ = sel => document.querySelector(sel);
const logEl = $("#log");
const roomDisplay = $("#roomDisplay");
const nickInput = $("#nickInput");
const joinBtn = $("#joinBtn");
const status = $("#status");
const msgInput = $("#msgInput");
const sendBtn = $("#sendBtn");

let ws = null;
let room = "";
let nick = "";
let connected = false;
let isJoining = false;
let reconnectTimer = null;
let pendingSends = [];

// Parse room from many URL styles
function parseRoomFromURL(){
  const u = window.location.href;
  // 1) query param ?room=name
  const params = new URLSearchParams(window.location.search);
  if(params.get("room")) return params.get("room").trim();

  // 2) hack.chat style: ?(room) or ?(room-name)
  const raw = window.location.search || "";
  const m = raw.match(/^\?\(([^)]+)\)/);
  if(m) return decodeURIComponent(m[1]).trim();

  // 3) hash fallback
  if(window.location.hash) return window.location.hash.substring(1).trim();

  return "";
}

function setStatus(text){
  status.textContent = text;
}

// pretty log
function appendLine(text, cls){
  const d = document.createElement("div");
  d.className = "line" + (cls?" "+cls:"");
  d.textContent = text;
  logEl.appendChild(d);
  d.scrollIntoView({behavior:"smooth", block:"end"});
}

// sanitize to avoid crash on unexpected messages
function safeParse(s){
  try{ return JSON.parse(s); } catch(e){ return null; }
}

// build join payload & open ws
function startConnection(){
  if(!room || !nick) return;
  if(ws && (ws.readyState === WebSocket.OPEN || ws.readyState===WebSocket.CONNECTING)) return;

  appendLine("[system] connecting to hack.chat relay...", "sys");
  setStatus("connecting...");
  isJoining = true;

  ws = new WebSocket("wss://ws.hack.chat/chat-ws");

  ws.addEventListener("open", () => {
    setStatus("connected");
    appendLine("[system] socket open", "sys");
    // send join
    const joinMsg = { cmd: "join", nick: nick, channel: room };
    try { ws.send(JSON.stringify(joinMsg)); }
    catch(e){ appendLine("[system] send join failed", "sys"); }
    connected = true;
    isJoining = false;
    // flush any pending sends
    while(pendingSends.length) {
      const m = pendingSends.shift();
      doSendRaw(m);
    }
  });

  ws.addEventListener("message", ev => {
    const data = safeParse(ev.data);
    if(!data) return;
    // hack.chat sends different cmd types
    if(data.cmd === "chat" && typeof data.text === "string"){
      // remote user's chat
      appendLine(`${data.nick}: ${data.text}`);
    } else if(data.cmd === "info"){
      appendLine(`[info] ${data.text}`, "sys");
    } else if(data.cmd === "onlineSet" && Array.isArray(data.nicks)){
      appendLine(`[system] users online: ${data.nicks.join(", ")}`, "sys");
    } else if(data.cmd === "raw"){
      // ignore
    } else {
      // other things
      //console.debug("unhandled", data);
    }
  });

  ws.addEventListener("close", ev => {
    connected = false;
    setStatus("disconnected");
    appendLine("[system] socket closed, attempting reconnect...", "sys");
    // attempt reconnect after short delay
    if(reconnectTimer) clearTimeout(reconnectTimer);
    reconnectTimer = setTimeout(()=> {
      // ensure socket destroyed
      try { ws.close(); } catch(e){}
      ws = null;
      startConnection();
    }, 2200);
  });

  ws.addEventListener("error", e => {
    setStatus("error");
    appendLine("[system] socket error", "sys");
  });
}

// send raw (assumes ws open)
function doSendRaw(obj){
  if(!ws || ws.readyState !== WebSocket.OPEN){
    pendingSends.push(obj);
    return;
  }
  try { ws.send(JSON.stringify(obj)); }
  catch(e){
    pendingSends.push(obj);
  }
}

// public send message (shows own message and sends chat)
function sendChatText(text){
  if(!text) return;
  // show locally immediately
  appendLine(`${nick}: ${text}`, "me");
  // hack.chat expects {cmd:"chat", text: "..."} with NO channel
  const payload = { cmd: "chat", text: text };
  doSendRaw(payload);
}

// parse initial room
room = parseRoomFromURL();
if(!room){
  // try to prompt once (if page opened without room)
  const r = prompt("Enter room name to join (this will appear in the URL):");
  if(r) {
    room = r.trim();
    // update URL to include ?room=... for convenience
    const newUrl = new URL(window.location.href);
    newUrl.search = "?room=" + encodeURIComponent(room);
    window.history.replaceState({}, "", newUrl.toString());
  }
}
roomDisplay.textContent = room || "(no room)";

// wire UI
joinBtn.addEventListener("click", () => {
  const n = nickInput.value.trim();
  if(!n){ alert("Enter a nickname"); nickInput.focus(); return; }
  nick = n;
  startConnection();
  setStatus("connecting (join sent)");
});

sendBtn.addEventListener("click", () => {
  const t = msgInput.value.trim();
  if(!t) return;
  if(!nick || !room) { alert("You must join first (room & nick)."); return; }
  sendChatText(t);
  msgInput.value = "";
  msgInput.focus();
});

// enter key to send message
msgInput.addEventListener("keydown", (ev) => {
  if(ev.key === "Enter" && !ev.shiftKey){
    ev.preventDefault();
    sendBtn.click();
  }
});

// allow pressing Enter in nick input to join quickly
nickInput.addEventListener("keydown", (ev)=>{
  if(ev.key === "Enter") joinBtn.click();
});

// auto-join if nick supplied in URL param ?nick=
(function tryAutoNick(){
  const params = new URLSearchParams(window.location.search);
  const n = params.get("nick") || "";
  if(n) { nickInput.value = n; nick = n; startConnection(); setStatus("connecting (auto)"); }
})();

// convenience: show a small system message telling format
appendLine("[system] room: " + room + "  — share exact URL (including ?room=NAME) with the other person", "sys");

</script>
</body>
</html>
